A51 MACRO ASSEMBLER  EVS33                                                                10/05/2023 21:24:46 PAGE     1


MACRO ASSEMBLER A51 V8.02b
OBJECT MODULE PLACED IN Evs33.OBJ
ASSEMBLER INVOKED BY: C:\Keil_v5\C51\BIN\A51.EXE Evs33.a51 SET(SMALL) DEBUG EP

LOC  OBJ            LINE     SOURCE

0000                   1     ORG 0H
0000 020006            2     LJMP INIT
0003                   3     ORG 03H
0003 020010            4     LJMP HANDLE_INTERRUPT
0006                   5     INIT:
  00C0                 6     P4 EQU 0C0h
0006 75A881            7     MOV IE,#10000001b; enable int0
0009 758801            8     MOV TCON, #1;1/0
000C                   9     WAIT_INTERRUPT:
000C F5C0             10     MOV P4, A;
000E 80FC             11     SJMP WAIT_INTERRUPT
0010                  12     HANDLE_INTERRUPT:
                      13     ; r1, r2 - buf registers
                      14     
  0000                15     BASEADDRESS_A EQU 00h
  0004                16     BASEADDRESS_B EQU 04h
  0020                17     RES_ADDRESS EQU 20h
0010 907FFA           18     MOV DPTR,#7FFAh
0013 E0               19     MOVX A,@DPTR;
0014 FA               20     MOV R2, A
0015 908000           21     MOV DPTR, #8000h
0018 20E477           22     JB ACC.4, PROGRAMM_C_1
                      23     ; if C = 0
001B                  24     PROGRAMM_C_0:
                      25     
001B 5403             26     ANL A, #00000011b ; read A1A0
001D 7B00             27     MOV R3, #BASEADDRESS_A
001F 2B               28     ADD A, R3 ; address of element in A array 
0020 F582             29     MOV DPL, A
0022 E0               30     MOVX A, @DPTR
0023 FB               31     MOV R3, A ; A[A1A0]
                      32     
0024 EA               33     MOV A, R2 ;read [C,B1,B0,A1,A0]
0025 540C             34     ANL A, #00001100b; read B1,B0
0027 03               35     RR A 
0028 03               36     RR A ; ACC.1 = B1, ACC.0 = B0
0029 7C04             37     MOV R4, #BASEADDRESS_B
002B 2C               38     ADD A, R4 ; address of element in B array
002C F582             39     MOV DPL, A
002E E0               40     MOVX A, @DPTR
002F FC               41     MOV R4, A ; B[B1B0]
                      42     
0030 EB               43     MOV A, R3
                      44     ; R4 = b, R3 = a
                      45     ; build 16-bit value in R5 (low 8 bit) and R6(high 8 bit)
                      46     ; build low bits for R5 in B
0031 A2E7             47     MOV C, ACC.7
0033 92F0             48     MOV B.0, C
                      49     
0035 A2E6             50     MOV C, ACC.6
0037 92F2             51     MOV B.2, C
                      52     
0039 A2E5             53     MOV C, ACC.5
003B 92F4             54     MOV B.4, C
                      55     
003D A2E4             56     MOV C, ACC.4
003F 92F6             57     MOV B.6, C
                      58     
A51 MACRO ASSEMBLER  EVS33                                                                10/05/2023 21:24:46 PAGE     2

0041 EC               59     MOV A, R4
                      60     
0042 A2E0             61     MOV C, ACC.0
0044 92F1             62     MOV B.1, C
                      63     
0046 A2E1             64     MOV C, ACC.1
0048 92F3             65     MOV B.3, C
                      66     
004A A2E2             67     MOV C, ACC.2
004C 92F5             68     MOV B.5, C
                      69     
004E A2E3             70     MOV C, ACC.3
0050 92F7             71     MOV B.7, C
                      72     
0052 ADF0             73     MOV R5, B ; R5 = B = b3,a4,b2,a5,b1,a6,b0,a7
                      74     ;build high bit for R6 in B
0054 EB               75     MOV A, R3
0055 A2E3             76     MOV C, ACC.3
0057 92F0             77     MOV B.0, C
                      78     
0059 A2E2             79     MOV C, ACC.2
005B 92F2             80     MOV B.2, C
                      81     
005D A2E1             82     MOV C, ACC.1
005F 92F4             83     MOV B.4, C
                      84     
0061 A2E0             85     MOV C, ACC.0
0063 92F6             86     MOV B.6, C
                      87     
0065 EC               88     MOV A, R4
                      89     
0066 A2E4             90     MOV C, ACC.4
0068 92F1             91     MOV B.1, C
                      92     
006A A2E5             93     MOV C, ACC.5
006C 92F3             94     MOV B.3, C
                      95     
006E A2E6             96     MOV C, ACC.6
0070 92F5             97     MOV B.5, C
                      98     
0072 A2E7             99     MOV C, ACC.7
0074 92F7            100     MOV B.7, C
                     101     
0076 AEF0            102     MOV R6, B; R6 = B = b7,a0,b6,a1,b5,a2,b4,a3
                     103     ; 16-bit value R6,R5
  0015               104     SEQ  EQU 00010101b
  001F               105     MASK EQU 00011111b
                     106     
0078 752000          107     MOV RES_ADDRESS,#00h ;init counter (use for this purpose result address)
007B ED              108     MOV A, R5
007C                 109     COUNT_CYCLE:
007C 541F            110     ANL A, #MASK
007E 9415            111     SUBB A, #SEQ ; check that last bits equal bit sequence
0080 7005            112     JNZ COUNT_NEXT
0082 E520            113     MOV A, RES_ADDRESS
0084 04              114     INC A
0085 F520            115     MOV RES_ADDRESS, A
0087                 116     COUNT_NEXT:
0087 C3              117     CLR C; C = 0
0088 EE              118     MOV A, R6 ; A = high bits of 16-bit value
0089 13              119     RRC A ; right shift of A, after which ACC.7 = 0 (because C = 0), 
                     120           ; ACC.n = ACC.(n + 1) n = 0...6 and new C = ACC.0 (previous ACC.0)
                     121               ; we have made arithmetic shift where C equals previous ACC.0 
008A FE              122     MOV R6, A ;save new high bits
008B ED              123     MOV A, R5 ; A = low bits of 16-bit value
008C 13              124     RRC A ; the same operation, but there prevous C is ACC.0 from high bits
A51 MACRO ASSEMBLER  EVS33                                                                10/05/2023 21:24:46 PAGE     3

                     125           ; so we shift our 16-bit value to right and fill higher bits by 0
008D 6054            126     JZ MOV_RESULT
008F FD              127     MOV R5, A ; save new low bits
0090 80EA            128     JMP COUNT_CYCLE
                     129     
                     130     ; if C = 1
0092                 131     PROGRAMM_C_1:
                     132     ; lets find maximum value in A array 
0092 5403            133     ANL A, #00000011b ; read A1A0
0094 FB              134     MOV R3, A
0095 7400            135     MOV A, #BASEADDRESS_A
0097 2B              136     ADD A, R3; upper board for maximum address in A array
0098 FB              137     MOV R3, A; save this board
                     138     
  0021               139     INDEX_ADDR EQU 21h ; address for storing index
  0022               140     MAX_A_ADDR EQU 22h ; address of maximum for A array
  0023               141     MAX_B_ADDR EQU 23h ; address of maximum for A array
                     142     ; cycle for finding maximum
0099 752100          143     MOV INDEX_ADDR, #BASEADDRESS_A ; address of i
009C 752200          144     MOV MAX_A_ADDR, #00h; maximum value in array A
009F                 145     MAXIMUM_SEARCH_CYCLE_A:
009F EB              146     MOV A, R3
00A0 9521            147     SUBB A, INDEX_ADDR; check address <= R3
00A2 4012            148     JC FIND_MAX_ARRAY_B
00A4 852182          149     MOV DPL, INDEX_ADDR
00A7 E0              150     MOVX A, @DPTR; get A[i]
00A8 9522            151     SUBB A, MAX_A_ADDR
00AA 4003            152     JC NEXT_INDEX_A
00AC E0              153     MOVX A, @DPTR
00AD F522            154     MOV MAX_A_ADDR, A; new maximum value
00AF                 155     NEXT_INDEX_A:
00AF E521            156     MOV A, INDEX_ADDR
00B1 04              157     INC A
00B2 F521            158     MOV INDEX_ADDR, A; increment i
00B4 80E9            159     JMP MAXIMUM_SEARCH_CYCLE_A
                     160     
00B6                 161     FIND_MAX_ARRAY_B:
                     162     ; lets find maximum value in B array
00B6 EA              163     MOV A, R2
00B7 540C            164     ANL A, #00001100b; read B1, B0
00B9 03              165     RR A
00BA 03              166     RR A ; ACC.1 = B1, ACC.0 = B0
00BB FC              167     MOV R4, A
00BC 7404            168     MOV A, #BASEADDRESS_B
00BE 2C              169     ADD A, R4; upper board for maximum address in B array
00BF FC              170     MOV R4, A; save this board
                     171     
                     172     ; cycle for finding maximum
00C0 752104          173     MOV INDEX_ADDR, #BASEADDRESS_B ; address of i
00C3 752300          174     MOV MAX_B_ADDR, #00h; maximum value in array B
00C6                 175     MAXIMUM_SEARCH_CYCLE_B:
00C6 EC              176     MOV A, R4
00C7 9521            177     SUBB A, INDEX_ADDR; check address <= R4
00C9 4012            178     JC CALCULATE_AND
00CB 852182          179     MOV DPL, INDEX_ADDR
00CE E0              180     MOVX A, @DPTR; get B[i]
00CF 9523            181     SUBB A, MAX_B_ADDR
00D1 4003            182     JC NEXT_INDEX_B
00D3 E0              183     MOVX A, @DPTR
00D4 F523            184     MOV MAX_B_ADDR, A; new maximum value
00D6                 185     NEXT_INDEX_B:
00D6 E521            186     MOV A, INDEX_ADDR
00D8 04              187     INC A
00D9 F521            188     MOV INDEX_ADDR, A; increment i
00DB 80E9            189     JMP MAXIMUM_SEARCH_CYCLE_B
                     190     
A51 MACRO ASSEMBLER  EVS33                                                                10/05/2023 21:24:46 PAGE     4

00DD                 191     CALCULATE_AND:
00DD E522            192     MOV A, MAX_A_ADDR
00DF 5523            193     ANL A, MAX_B_ADDR
00E1 F520            194     MOV RES_ADDRESS, A
                     195     
00E3                 196     MOV_RESULT:
00E3 E520            197     MOV A, RES_ADDRESS
00E5 F9              198     MOV R1, A
00E6 89C0            199     MOV P4, R1
                     200     
00E8                 201     HANDLE_END:
                     202     ;end of interrupt process
00E8 89C0            203     MOV P4, R1
00EA 32              204     RETI
                     205     END
A51 MACRO ASSEMBLER  EVS33                                                                10/05/2023 21:24:46 PAGE     5

SYMBOL TABLE LISTING
------ ----- -------


N A M E                 T Y P E  V A L U E   ATTRIBUTES

ACC. . . . . . . . . .  D ADDR   00E0H   A   
B. . . . . . . . . . .  D ADDR   00F0H   A   
BASEADDRESS_A. . . . .  N NUMB   0000H   A   
BASEADDRESS_B. . . . .  N NUMB   0004H   A   
CALCULATE_AND. . . . .  C ADDR   00DDH   A   
COUNT_CYCLE. . . . . .  C ADDR   007CH   A   
COUNT_NEXT . . . . . .  C ADDR   0087H   A   
DPL. . . . . . . . . .  D ADDR   0082H   A   
FIND_MAX_ARRAY_B . . .  C ADDR   00B6H   A   
HANDLE_END . . . . . .  C ADDR   00E8H   A   
HANDLE_INTERRUPT . . .  C ADDR   0010H   A   
IE . . . . . . . . . .  D ADDR   00A8H   A   
INDEX_ADDR . . . . . .  N NUMB   0021H   A   
INIT . . . . . . . . .  C ADDR   0006H   A   
MASK . . . . . . . . .  N NUMB   001FH   A   
MAXIMUM_SEARCH_CYCLE_A  C ADDR   009FH   A   
MAXIMUM_SEARCH_CYCLE_B  C ADDR   00C6H   A   
MAX_A_ADDR . . . . . .  N NUMB   0022H   A   
MAX_B_ADDR . . . . . .  N NUMB   0023H   A   
MOV_RESULT . . . . . .  C ADDR   00E3H   A   
NEXT_INDEX_A . . . . .  C ADDR   00AFH   A   
NEXT_INDEX_B . . . . .  C ADDR   00D6H   A   
P4 . . . . . . . . . .  N NUMB   00C0H   A   
PROGRAMM_C_0 . . . . .  C ADDR   001BH   A   
PROGRAMM_C_1 . . . . .  C ADDR   0092H   A   
RES_ADDRESS. . . . . .  N NUMB   0020H   A   
SEQ. . . . . . . . . .  N NUMB   0015H   A   
TCON . . . . . . . . .  D ADDR   0088H   A   
WAIT_INTERRUPT . . . .  C ADDR   000CH   A   


REGISTER BANK(S) USED: 0 


ASSEMBLY COMPLETE.  0 WARNING(S), 0 ERROR(S)
