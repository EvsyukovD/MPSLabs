	ORG 0000H
;----main constants--
	P4 EQU 0C0H
	;P0 EQU 080H
	;P1 EQU 090H
	TASK EQU 2
	SUCCESS_CODE EQU 055h
	BLOCK_CODE EQU 0AAh
	PASSWORD_BASE_ADDRESS EQU 20h; we store password as array
	TRIES_COUNT_ADDRESS EQU 24h; number of tries
	N_ADDRESS EQU 25h; upper bound of tries
	
;----buffer-------
	CURRENT_VAL_ADDRESS EQU 26h
	PREV_VAL_ADDRESS EQU 27h
;-----------------	

	INDEX_ADDRESS EQU 28h
	CORRECT_ANSWERS_ADDR EQU 29h
;N(i) errors count for calculating N(i + 1)
	N1_ADDRESS EQU 2Ah
	N2_ADDRESS EQU 2Bh
	N3_ADDRESS EQU 2Ch
;---init values------------
INIT:
	MOV P0, #00h
	MOV P1, #00h
	MOV P2, #00h
	MOV PREV_VAL_ADDRESS, #00h
	MOV N_ADDRESS, #2; N1
	MOV N1_ADDRESS, N_ADDRESS
	MOV TRIES_COUNT_ADDRESS, #00h
	MOV CORRECT_ANSWERS_ADDR, #00h
;----init password------
	MOV PASSWORD_BASE_ADDRESS, #0
	MOV A, #PASSWORD_BASE_ADDRESS
	INC A
	XCH A, R0
	MOV @R0, #2
	XCH A, R0
	INC A
	XCH A, R0
	MOV @R0, #4
	XCH A, R0
	INC A
	XCH A, R0
	MOV @R0, #5
;-----------------------
	MOV R0, PASSWORD_BASE_ADDRESS; R0 contains current correct bit
POLLING_P0_CYCLE:
	MOV A, P0
	MOV CURRENT_VAL_ADDRESS, A
	XRL A, PREV_VAL_ADDRESS
	JZ POLLING_P0_CYCLE; is P0 changed?
	MOV PREV_VAL_ADDRESS, CURRENT_VAL_ADDRESS
	MOV INDEX_ADDRESS, #00h
GET_BIT:; extract bits via right rotate
	JB ACC.0, CHECK_ERROR
	XCH A, INDEX_ADDRESS
	INC A
	XCH A, INDEX_ADDRESS; now index contains bit number
	RR A
	AJMP GET_BIT
CHECK_ERROR:
    MOV A, #PASSWORD_BASE_ADDRESS
	ADD A, CORRECT_ANSWERS_ADDR
	MOV R1, A
	MOV A, @R1
	MOV R0, A; now R0 contains correct value from password
	MOV A, INDEX_ADDRESS
	SUBB A, R0
	JZ PROCESS_CORRECT_BIT
PROCESS_ERROR_BIT:
    CLR C; clear C after subb
    MOV A, TRIES_COUNT_ADDRESS
	INC A
	MOV TRIES_COUNT_ADDRESS, A
	MOV A, N_ADDRESS
	SUBB A, TRIES_COUNT_ADDRESS; check that N >= tries_count
    JBC PSW.7, BLOCK_CYCLE
    LJMP POLLING_P0_CYCLE
PROCESS_CORRECT_BIT:
    MOV A, CORRECT_ANSWERS_ADDR
	INC A
	MOV CORRECT_ANSWERS_ADDR, A
;lets define which Ni we need to calculate
	MOV A, #1; N2, because CORRECT_ANSWERS_ADDR from {0,1,2,3}
	SUBB A, CORRECT_ANSWERS_ADDR
	JZ CALC_N2
	
	CLR C; if C is 1 (A < CORRECT_ANSWERS_ADDR)
	MOV A, #2; N3
	SUBB A, CORRECT_ANSWERS_ADDR
	JZ CALC_N3
	
	CLR C
	MOV A, #3; N4
	SUBB A, CORRECT_ANSWERS_ADDR
	JZ CALC_N4
	
	CLR C
	MOV A, #4; finish, password is correct
	SUBB A, CORRECT_ANSWERS_ADDR
	JZ CORRECT_PASSWORD
CALC_N2:
	MOV N_ADDRESS, #3; new upper bound value for errors number
	MOV N1_ADDRESS, TRIES_COUNT_ADDRESS; num of tries on first iter
	MOV TRIES_COUNT_ADDRESS, #00h
	LJMP POLLING_P0_CYCLE
CALC_N3:
    MOV A, N1_ADDRESS
	MOV N2_ADDRESS, TRIES_COUNT_ADDRESS; num of tries on second iter
	ADD A, N2_ADDRESS
	ANL A, #01h
	MOV N_ADDRESS, A; new upper bound value for errors number
	MOV TRIES_COUNT_ADDRESS, #00h
    LJMP POLLING_P0_CYCLE
CALC_N4:
    MOV N3_ADDRESS, TRIES_COUNT_ADDRESS
	MOV TRIES_COUNT_ADDRESS, #00h
	MOV A, N1_ADDRESS
    ADD A, N2_ADDRESS
	ADD A, N3_ADDRESS
	MOV R2, A; save sum of N1,N2,N3
	MOV R1, #5
	SUBB A, R1
	JBC PSW.7, EXCHANGE
	MOV N_ADDRESS, A
	
EXCHANGE:
    MOV A, R2
	XCH A, R1
	SUBB A, R1
	MOV N_ADDRESS, A
	LJMP POLLING_P0_CYCLE


BLOCK_CYCLE:
	MOV P1, #BLOCK_CODE
	AJMP BLOCK_CYCLE

CORRECT_PASSWORD:
    MOV P1, #SUCCESS_CODE
	MOV P2, #TASK
	LJMP INIT
	END